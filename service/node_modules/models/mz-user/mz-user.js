'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util');
var mongoose = require('mongoose');
var Schema = mongoose.Schema;

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.metaData = {};
	this.addMeta = function(name, data) {
		this.metaData[name] = data;
	}



	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'mzMongoUrl',
				optional: false
			},
			{
				name: 'databaseName',
				optional: false
			}
		]
	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	//SETUP ====================================


	var dataModel = function() {
		//thanks: https://scotch.io/tutorials/using-mongoosejs-in-node-js-and-mongodb-applications
		
		var modelName='User';
		
		var schema = new Schema({
			displayName: String,
			userName: {
				type: String,
				required: true,
				unique: true
			},
			emailAdr: {
				type: String,
				required: true,
				unique: true
			},
			password: {
				type: String
			},
			roles: [
				{
					role: String
				}
			],
			created_at: {
				type: Date,
				default: Date.now
			},
			updated_at: {
				type: Date,
				default: Date.now
			}
		});


		schema.methods.formatInfoString = function() {
			this.password = this.password; //right now, plain text is good

			return this.displayName + '/' + this.userName + '/' + this.emailAdr;
		};

		// schema.pre('save', function(next){
		//   this.password = this.password; //should be hash but right now, plain text is good
		//   this.updated_at=new Date();
		//   next();
		// });
		return self.db.model(modelName, schema);
	};

	//LOCAL FUNCTIONS ====================================
	var initDb = function() {
		self.db = mongoose.createConnection(self.mzMongoUrl + self.databaseName);
		self.db.on('error', function(err) {
			throw ("mz-user says, mongoose failed")
		});
	}
	var printError = function(err, result, extraFunction) {
		qtools.dump({
			err: err
		});
	}
	var wrapCallback = function(callback) {
		return function(err, result) {
			if (typeof (extraFunction) == 'function') {
				extraFunction(err, result);
			}
			//make it more visible for debugging: err=err && new Error(err.toString());
			callback(err, result);
		}
	}
	
	// NON-SPECIFIC METHODS AND PROPERTIES ====================================

	self.ping = function(indicator) {
		return indicator;
	}

	self.deleteAllForTest = function(callback) {
		if (self.databaseName.match(/test/i)) {
			modelHandle.find({}).remove(wrapCallback(callback));
		} else {
			callback({
				message: "deleting users is only allowed on test databases"
			});
		}

	}
	
	//METHODS AND PROPERTIES ====================================

	self.registerUser = function(user, callback) {
		callback = callback ? callback : printError;

		user.roles = user.roles ? user.roles : [];
		user.roles.filter(function(item) {
			return (['admin', 'recipient'].indexOf(item.role) != -1);
		});

		user.roles.push({
			role: 'admin'
		});
		user.roles.push({
			role: 'recipient'
		});

		if (!user.password) {
			callback({
				message: 'Password is required'
			}, '');
			return;
		}

		if (!user.userName) {
			callback({
				message: 'User Name is required'
			}, '');
			return;
		}

		var newUser = new modelHandle(user);
		newUser.save(wrapCallback(callback));
	}

	self.getUser = function(userName, expectedFormat, callback) {
		var query = modelHandle.findOne({
			userName: userName
		});

		switch (expectedFormat){
			case 'lean':
			query.lean().exec(wrapCallback(callback));
			break;
			case 'fat':
			query.exec(wrapCallback(callback));
			break;
			default:
				callback('', new Error("expectedFormat must be wither 'lean' (plain javascript object) or 'fat' (mongoose object)"));
			break;
		}
	}
	
	var hashFunction = function(password) {
		return password;
	}
	
	self.authenticate = function(user, callback) {
		var query = modelHandle.findOne({
			userName: user.userName,
			password: hashFunction(user.password)
		});
		query.exec(function(err, result) {
			if (result && result.userName) {
				callback('', true);
			} else {
				callback(true);
			}
		});
	}

	self.addRecipientRole = function(recipient, callback) {
		modelHandle.update(
		{
			title: recipient.userName
		},
		{
			$addToSet: {
				roles: [
					{
						emailAdr: recipient.emailAdr
					}
				]
			}
		},
		wrapCallback(callback)

		);}

	self.countRecipients = function(query, callback) {
		var query = modelHandle.count(query);
		query.exec(wrapCallback(callback));
	}

	//INITIALIZATION ====================================
	initDb();
	var modelHandle = dataModel();

	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;













